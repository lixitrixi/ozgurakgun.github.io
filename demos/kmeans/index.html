<!--

Written by Özgür Akgün on 9/10 April 2018, as a demo for CS1003 W09.

This was developed very quickly, maybe over 2 hours after midnight.
So apologies if something doesn't work quite in the way you expect it to be.

Hope this helps!
Oz

-->


<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">

    <!--
        This disables zooming on mobile. Replace with the following to enable it again.
        <meta name="viewport" content="width=device-width, initial-scale=1">
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <title> CS1003 k-means demo </title>

    <!-- import bootstrap -->
    <link
        href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
        rel="stylesheet"
        integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        crossorigin="anonymous">

    <!-- empty favicon -->
    <link href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=" rel="icon" type="image/x-icon">

    <script>

        // to play with this demo, use the following functions
        // - initialCentroids           -- randomly place k centroids
        // - assignToCentroids          -- assign each data point to its nearest centroid
        // - updateCentroids            -- update the centroids to the average f all points in this cluster
        // - kmeans                     -- combined
        // - redraw                     -- redraw the grid



        // number of clusters
        var k = 3

        var showCentroids = true

        var centroids_x = []
        var centroids_y = []

        // the grid is 100x100 "boxes"
        var gridSize = 100

        // each box is 10x10 pixels
        var boxSize = 10

        var grid = []

        var colours = ["black", "red", "blue", "green", "orange", "yellow", "aqua", "fuchsia", "lime", "maroon", "purple", "teal"]

        var canvas = null;
        var ctx = null;

        function __drawCircle(ctx, colour, x, y, r) {
            ctx.beginPath()
            ctx.arc(x, y, r, 0, Math.PI * 2, true);
            ctx.fillStyle = colour
            ctx.fill()
        }

        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (i = 0; i < gridSize; i++) {
                for (j = 0; j < gridSize; j++) {
                    if (grid[i][j] >= 0) {
                        ctx.fillStyle = colours[grid[i][j]];
                        ctx.fillRect( i * boxSize
                                    , j * boxSize
                                    , boxSize
                                    , boxSize
                                    );
                    }
                }
            }
            if (showCentroids) {
                for (i = 1; i <= k; i++) {
                    __drawCircle( ctx
                                , colours[i]
                                , centroids_x[i] * boxSize
                                , centroids_y[i] * boxSize
                                , boxSize
                                );
                }
            }
        }

        function initialCentroids() {
            allPoints_x = []
            allPoints_y = []
            for (i = 0; i < gridSize; i++) {
                for (j = 0; j < gridSize; j++) {
                    if (grid[i][j] >= 0) {
                        allPoints_x.push(i)
                        allPoints_y.push(j)
                    }
                }
            }

            chosen_poins = []

            centroids_x = []
            centroids_y = []
            for (i = 1; i <= k; i++) {
                var point = Math.floor(Math.random() * allPoints_x.length);
                chosen_poins.push(point)
                centroids_x[i] = allPoints_x[point]
                centroids_y[i] = allPoints_y[point]
            }


            // console.log(centroids_x)
            // console.log(centroids_y)

            // if we managed to choose the same point twice, redo
            if (new Set(chosen_poins).size !== chosen_poins.length) {
                initialCentroids()
            } else {
                redraw()
            }
        }

        function closestCentroid(x, y) {
            found = null
            minDist = 10000000
            for (c = 1; c <= k; c++) {
                dist = Math.sqrt(Math.pow(x - centroids_x[c], 2) + Math.pow(y - centroids_y[c], 2))
                // console.log(c, dist)
                if (dist <= minDist) {
                    minDist = dist
                    found = c
                }
            }
            return found
        }

        function assignToCentroids() {
            for (i = 0; i < gridSize; i++) {
                for (j = 0; j < gridSize; j++) {
                    if (grid[i][j] >= 0) {
                        c = closestCentroid(i, j)
                        // console.log(i, j, grid[i][j], c)
                        grid[i][j] = c
                    }
                }
            }
            redraw()
        }

        function updateCentroids() {
            sums_x = []
            sums_y = []
            counts = []

            for (c = 1; c <= k; c++) {
                sums_x[c] = 0
                sums_y[c] = 0
                counts[c] = 0
            }

            for (i = 0; i < gridSize; i++) {
                for (j = 0; j < gridSize; j++) {
                    c = grid[i][j]
                    if (c >= 1) {
                        sums_x[c] += i
                        sums_y[c] += j
                        counts[c] += 1
                    }
                }
            }

            for (c = 1; c <= k; c++) {
                new_x = Math.round(sums_x[c] / counts[c])
                new_y = Math.round(sums_y[c] / counts[c])
                if (isNaN(new_x) || isNaN(new_y)) {
                    // console.log(c, centroids_x[c], centroids_y[c], sums_x[c], sums_y[c], counts[c], "NaN")
                } else {
                    centroids_x[c] = new_x
                    centroids_y[c] = new_y
                    // console.log(c, centroids_x[c], centroids_y[c], sums_x[c], sums_y[c], counts[c])
                }
            }

            redraw()
        }

        function kmeans() {
            initialCentroids()
            do {
                prevgrid = JSON.stringify(grid)
                assignToCentroids()
                updateCentroids()
            } while (prevgrid != JSON.stringify(grid));
        }

        window.onload = function() {

            canvas = document.getElementById("c");
            ctx = canvas.getContext("2d");

            for (i = 0; i < gridSize; i++) {
                var row = [];
                for (j = 0; j < gridSize; j++) {
                    row[j] = -1;
                }
                grid[i] = row;
            }

            canvas.addEventListener('click', function(event) {
                var x = event.offsetX;
                var y = event.offsetY;

                x = Math.floor(x / boxSize)
                y = Math.floor(y / boxSize)

                if (grid[x][y] != -1) {
                    // if turned on, turn off
                    grid[x][y] = -1
                } else {
                    // if turned off, paint it black
                    grid[x][y] = 0
                }

                // initialCentroids()
                redraw()

                // console.log(event.offsetX, event.offsetY);

            });

            canvas.addEventListener('dblclick', function(event) {
                var x = event.offsetX;
                var y = event.offsetY;

                x = Math.floor(x / boxSize)
                y = Math.floor(y / boxSize)

                for (i = -10; i <= 10; i++) {
                    for (j = -10; j <= 10; j++) {
                        // inside the box
                        if (0 <= x+i && x+i < gridSize && 0 <= y+j && y+j < gridSize) {
                            // inside a circle or radius=5
                            if (Math.sqrt(Math.pow(i, 2) + Math.pow(j, 2)) <= 5) {
                                // with 30% likelihood
                                if (Math.random() < 0.3) {
                                    // turn it on
                                    grid[x+i][y+j] = 0
                                }
                            }
                        }
                    }
                }


                // initialCentroids()
                redraw()



                // console.log(event.offsetX, event.offsetY);

            });

        }

    </script>

</head>

<body>

<div class="container">
    <h1>Demo: k-means</h1>
    <br>
    <canvas id="c" width="1000px" height="1000px" style="border:1px solid #000000;"> </canvas>
    <br>
    <h2>Notes</h2>
    <p>This demo is intended to be run through a JavaScript console.</p>
    <ul>
        <li>
            Click on the grid to create some data points.
        </li>
        <li>
            Double-click to create a bunch of points at once.
        </li>
        <li>
            Open the JavaScript console in your web browser. The following functions are available.
            <ul>
                <li>
                    <strong>initialCentroids</strong>           -- randomly place k centroids
                </li>
                <li>
                    <strong>assignToCentroids</strong>          -- assign each data point to its nearest centroid
                </li>
                <li>
                    <strong>updateCentroids</strong>            -- update the centroids to the average f all points in this cluster
                </li>
                <li>
                    <strong>kmeans</strong>                     -- Combined. Run <strong>initialCentroids</strong> once, followed by <strong>assignToCentroids</strong> and <strong>updateCentroids</strong> in a loop until nothing changes.
                </li>
                <li>
                    <strong>k = NUMBER</strong>                 -- set the value of k to NUMBER. 3 by default. Do not set it to more than 10, I have only defined that many colours!
                </li>
            </ul>
        </li>
    </ul>
</div>

<script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-22790558-1']);
    _gaq.push(['_trackPageview']);
    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
</script>

</body>

</html>






